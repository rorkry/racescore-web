# 競うスコア ロジック詳細仕様書

**作成日**: 2026年1月4日  
**ファイル**: `utils/getClusterData.ts` の `computeKisoScore` 関数  
**バージョン**: v2.0（indicesテーブル指数使用版）

---

## 📊 スコア構成概要

競うスコアは **最大100点満点** で計算され、以下の6つの要素から構成されます：

| 評価項目 | 配点 | 説明 |
|---------|------|------|
| **巻き返し指数** | 40点 | indicesテーブルの`makikaeshi`を使用 |
| **ポテンシャル指数** | 25点 | indicesテーブルの`potential`を使用 |
| **着順** | 10点 | 前走の着順評価 |
| **着差** | 10点 | 前走の着差評価 |
| **クラスタタイム** | 8点 | 同条件の1着馬タイムとの比較 |
| **通過順位×ペース** | 7点 | 前走の位置取りとペースの組み合わせ |
| **合計** | **100点** | 全要素の合算 |

---

## 1️⃣ 巻き返し指数スコア（40点満点）

### データソース
- `indices.makikaeshi` カラムから取得（10点満点の指数）

### 計算式
```
巻き返しスコア = (前走巻き返し指数 / 10) × 28
               + (2走前巻き返し指数 / 10) × 8
               + (3走前巻き返し指数 / 10) × 4
```

### 配点内訳
| 走次 | 最大配点 | ウェイト |
|------|---------|---------|
| 前走 | 28点 | 70% |
| 2走前 | 8点 | 20% |
| 3走前 | 4点 | 10% |

### 実装コード（300-314行目）
```typescript
const comeback1 = getIndexValue(recent[0], 'makikaeshi');
const comeback2 = getIndexValue(recent[1], 'makikaeshi');
const comeback3 = getIndexValue(recent[2], 'makikaeshi');

const comebackScore = 
  (comeback1 / 10) * 28 +  // 前走: 28点
  (comeback2 / 10) * 8 +   // 2走前: 8点
  (comeback3 / 10) * 4;    // 3走前: 4点
```

### 具体例
- 前走: 巻き返し指数 8.0 → 8.0 / 10 × 28 = **22.4点**
- 2走前: 巻き返し指数 6.0 → 6.0 / 10 × 8 = **4.8点**
- 3走前: 巻き返し指数 5.0 → 5.0 / 10 × 4 = **2.0点**
- **合計**: 22.4 + 4.8 + 2.0 = **29.2点**

---

## 2️⃣ ポテンシャル指数スコア（25点満点）

### データソース
- `indices.potential` カラムから取得（10点満点の指数）

### 計算ロジック
1. **直近3走の有効データを抽出**（0より大きい値のみ）
2. **平均値と最高値を算出**
3. **総合評価値 = 平均値 × 80% + 最高値 × 20%**
4. **基本点（20点満点）= (総合評価値 / 10) × 20**
5. **ボーナス点（最大5点）**:
   - 総合評価値が **3.0以上** から加点開始
   - 計算式: `min(5, (総合評価値 - 3.0) × 0.8 + 0.8)`

### 実装コード（318-345行目）
```typescript
const potential1 = getIndexValue(recent[0], 'potential');
const potential2 = getIndexValue(recent[1], 'potential');
const potential3 = getIndexValue(recent[2], 'potential');

// 有効なデータのみで平均と最高値を計算
const potentialValues = [potential1, potential2, potential3].filter(v => v > 0);
const potentialAvg = potentialValues.length > 0 
  ? potentialValues.reduce((a, b) => a + b, 0) / potentialValues.length 
  : 0;
const potentialMax = potentialValues.length > 0 
  ? Math.max(...potentialValues)
  : 0;

// 平均80% + 最高値20%で総合評価値を算出
const potentialCombined = potentialAvg * 0.8 + potentialMax * 0.2;

// 基本点（20点満点）
const potentialBaseScore = (potentialCombined / 10) * 20;

// ボーナス（総合評価3.0以上から加点、1上がるごとに+0.8、最大5点）
let potentialBonus = 0;
if (potentialCombined >= 3.0) {
  potentialBonus = Math.min(5, (potentialCombined - 3.0) * 0.8 + 0.8);
}

const potentialScore = potentialBaseScore + potentialBonus;
```

### 具体例
#### ケース1: 高ポテンシャル馬
- 前走: 8.5、2走前: 7.8、3走前: 9.2
- 平均: 8.5 → 最高: 9.2
- 総合評価値: 8.5 × 0.8 + 9.2 × 0.2 = **8.64**
- 基本点: (8.64 / 10) × 20 = **17.28点**
- ボーナス: min(5, (8.64 - 3.0) × 0.8 + 0.8) = **5.0点**
- **合計**: 17.28 + 5.0 = **22.28点**

#### ケース2: 中程度のポテンシャル馬
- 前走: 5.0、2走前: 4.5、3走前: 5.5
- 平均: 5.0 → 最高: 5.5
- 総合評価値: 5.0 × 0.8 + 5.5 × 0.2 = **5.1**
- 基本点: (5.1 / 10) × 20 = **10.2点**
- ボーナス: min(5, (5.1 - 3.0) × 0.8 + 0.8) = **2.48点**
- **合計**: 10.2 + 2.48 = **12.68点**

---

## 3️⃣ 着順スコア（10点満点）

### 計算式
```
着順スコア = max(0, 10 - (前走着順 - 1) × 1)
```

### 実装コード（348-351行目）
```typescript
const fin1 = parseInt(toHalfWidth(GET(recent[0] || {}, 'finish', '着順').trim()), 10) || 99;
const finishScore = Math.max(0, 10 - (fin1 - 1) * 1);
```

### 配点表
| 着順 | 得点 |
|------|------|
| 1着 | 10点 |
| 2着 | 9点 |
| 3着 | 8点 |
| 4着 | 7点 |
| 5着 | 6点 |
| 6着 | 5点 |
| 7着 | 4点 |
| 8着 | 3点 |
| 9着 | 2点 |
| 10着 | 1点 |
| 11着以下 | 0点 |

---

## 4️⃣ 着差スコア（10点満点）

### 計算式
```
着差スコア = max(0, 10 - 着差(秒) × 3)
```

### 実装コード（353-357行目）
```typescript
const margin1 = parseFloat(GET(recent[0] || {}, 'margin', '着差') || '0');
const marginScoreVal = Math.max(0, 10 - margin1 * 3);
```

### 配点表
| 着差 | 得点 |
|------|------|
| 0.0秒（勝ち馬） | 10点 |
| 0.3秒 | 9.1点 |
| 0.5秒 | 8.5点 |
| 1.0秒 | 7.0点 |
| 1.5秒 | 5.5点 |
| 2.0秒 | 4.0点 |
| 2.5秒 | 2.5点 |
| 3.0秒 | 1.0点 |
| 3.4秒以上 | 0点 |

---

## 5️⃣ クラスタタイムスコア（8点満点）

### 概要
同日±1日、同場所、同距離の1着馬タイムと比較して評価

### 現在の実装（362行目）
```typescript
const clusterScore = 4; // 仮実装（後で詳細化可能）
```

### ⚠️ 注意
現在は **固定で4点** を付与しています。将来的に以下のロジックで詳細化予定：
- 自馬のタイムが別クラスの1着馬タイムより速い → 高得点
- 上位クラスの1着馬と近いタイム → 高得点
- タイム差が大きい → 減点

---

## 6️⃣ 通過順位×ペーススコア（7点満点）

### 計算ステップ

#### ステップ1: 平均通過順位の算出
```
平均通過順位 = (2コーナー + 3コーナー + 4コーナー) / 3
```

#### ステップ2: 基本通過スコア
```
基本スコア = (頭数 - 平均通過順位 + 1) / 頭数
```

#### ステップ3: ペースカテゴリの判定

| 芝/ダ | 距離 | PCI範囲 | ペースカテゴリ | ペース係数 |
|-------|------|---------|---------------|-----------|
| ダート | ≤1600m | ≤41 | 超ハイ | 1.2 |
| ダート | ≤1600m | ≤42 | ハイ | 1.1 |
| ダート | ≤1600m | 43-47 | ミドル | 1.0 |
| ダート | ≤1600m | ≥48 | スロー | 0.9 |
| ダート | ≤1600m | ≥49 | 超スロー | 0.8 |
| ダート | ≥1700m | ≤44 | 超ハイ | 1.2 |
| ダート | ≥1700m | ≤45 | ハイ | 1.1 |
| ダート | ≥1700m | 46-47 | ミドル | 1.0 |
| ダート | ≥1700m | ≥48 | スロー | 0.9 |
| ダート | ≥1700m | ≥49 | 超スロー | 0.8 |
| 芝 | ≥1700m | ≤47.5 | 超ハイ | 1.2 |
| 芝 | ≥1700m | ≤50 | ハイ | 1.1 |
| 芝 | ≥1700m | 50.1-55.9 | ミドル | 1.0 |
| 芝 | ≥1700m | ≥56 | スロー | 0.9 |
| 芝 | ≥1700m | ≥57 | 超スロー | 0.8 |
| 芝 | ≤1600m | ≤46 | 超ハイ | 1.2 |
| 芝 | ≤1600m | ≤47 | ハイ | 1.1 |
| 芝 | ≤1600m | 48-49 | ミドル | 1.0 |
| 芝 | ≤1600m | ≥50 | スロー | 0.9 |
| 芝 | ≤1600m | ≥52 | 超スロー | 0.8 |

#### ステップ4: 最終スコア
```
通過順位×ペーススコア = 基本スコア × ペース係数 × 7
```

### 実装コード（365-386行目）
```typescript
const passNums = ['corner2', 'corner3', 'corner4']
  .map(k => {
    const raw = toHalfWidth(GET(recent[0] || {}, k, k).trim());
    const m = raw.match(/^\d+/);
    return m ? parseInt(m[0], 10) : NaN;
  })
  .filter(n => !isNaN(n));

const fieldSize = parseInt(GET(recent[0] || {}, 'fieldSize', '頭数') || '1', 10);
const avgPass = passNums.length
  ? passNums.reduce((a, b) => a + b, 0) / passNums.length
  : fieldSize;

const basePassScore = Math.max(0, (fieldSize - avgPass + 1) / fieldSize);
const surf = (GET(recent[0] || {}, 'surface', '距離').trim().charAt(0) as '芝'|'ダ') || '芝';
const dist = parseInt(GET(recent[0] || {}, 'distance', '距離').replace(/[^\d]/g, '') || '0', 10);
const pci = parseFloat(GET(recent[0] || {}, 'pci', 'PCI') || '0');
const paceCat = getPaceCat(surf, dist, pci);
const passFactor = paceFactorMap[paceCat];
const passScore = basePassScore * passFactor * 7;
```

### 具体例
#### ケース1: 前が有利だが超スローペース
- 18頭立て、平均通過順位: 3着
- 芝1800m、PCI: 57（超スロー）
- 基本スコア: (18 - 3 + 1) / 18 = **0.889**
- ペース係数: **0.8**（超スロー）
- 最終スコア: 0.889 × 0.8 × 7 = **4.98点**

#### ケース2: 後方だが超ハイペース
- 16頭立て、平均通過順位: 12着
- ダート1400m、PCI: 41（超ハイ）
- 基本スコア: (16 - 12 + 1) / 16 = **0.3125**
- ペース係数: **1.2**（超ハイ）
- 最終スコア: 0.3125 × 1.2 × 7 = **2.625点**

---

## 🔄 最終スコア計算

### 合算と範囲制限（392-394行目）
```typescript
const totalScore = comebackScore + potentialScore + finishScore + marginScoreVal + clusterScore + passScore;

return Math.min(100, Math.max(0, +totalScore.toFixed(1)));
```

### 計算例
| 要素 | 得点 |
|------|------|
| 巻き返し指数 | 29.2点 |
| ポテンシャル指数 | 22.3点 |
| 着順 | 9.0点 |
| 着差 | 7.0点 |
| クラスタタイム | 4.0点 |
| 通過順位×ペース | 4.98点 |
| **合計** | **76.48点** |

小数点第1位で丸めて **76.5点** として出力

---

## 📌 重要な仕様

### 1. 使用する過去走数
- **直近5走** までを対象（`recent = horse.past.slice(0, 5)`）

### 2. データ取得の優先順位
```typescript
function GET(row: RecordRow, ...keys: string[]): string
```
- 複数のカラム名候補を試して、最初に有効な値を返す
- 例: `GET(race, 'finish', '着順')` → 'finish' が存在すれば使用、なければ '着順' を使用

### 3. indicesテーブルとの連携
```typescript
function getIndexValue(race: any, key: string): number {
  if (race && race.indices && race.indices[key] !== null && race.indices[key] !== undefined) {
    return parseFloat(race.indices[key]) || 0;
  }
  return 0;
}
```
- 過去走データに `indices` オブジェクトが含まれている必要がある
- indicesテーブルとのJOINは `pages/api/race-card-with-score.ts` で実施

### 4. スコア範囲
- **最小値**: 0点
- **最大値**: 100点
- 小数点第1位まで表示

---

## 🔧 今後の改善ポイント

### 1. クラスタタイムスコアの詳細化
現在は固定4点だが、以下のロジックを実装予定：
- 同条件1着馬タイムとの差分計算
- クラス格上の1着馬との比較
- タイム差に応じた段階的な評価

### 2. 最高速度の考慮
- 前半2Fの最高速度を加味
- 過去メンバー比較で突出した速度を評価

### 3. 距離の短縮・延長の評価
- 前走距離と今回距離の差を考慮
- 距離適性の分析

---

## 📂 関連ファイル

| ファイルパス | 役割 |
|-------------|------|
| `utils/getClusterData.ts` | スコア計算ロジック本体 |
| `pages/api/race-card-with-score.ts` | APIエンドポイント（スコア計算呼び出し） |
| `app/page.tsx` | フロントエンド（スコア表示） |
| `types/record.ts` | RecordRow型定義 |

---

## 🧪 テスト用SQL

### スコア計算に必要なデータの確認
```sql
-- 馬の過去走データ + 指数データの取得例
SELECT 
  u.*,
  i.makikaeshi,
  i.potential,
  i.L4F,
  i.T2F
FROM umadata u
LEFT JOIN indices i ON i.race_id = u.race_id_new_no_horse_num || printf('%02d', u.horse_number)
WHERE u.horse_name = '〇〇〇〇'
ORDER BY u.date DESC
LIMIT 5;
```

---

**📝 ドキュメント終了**









